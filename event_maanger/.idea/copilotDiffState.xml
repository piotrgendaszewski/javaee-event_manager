<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/JWT/JwtFilter.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/JWT/JwtFilter.java" />
              <option name="originalContent" value="package JWT;&#10;&#10;import io.jsonwebtoken.Claims;&#10;import jakarta.annotation.Priority;&#10;import jakarta.ws.rs.Priorities;&#10;import jakarta.ws.rs.container.ContainerRequestContext;&#10;import jakarta.ws.rs.container.ContainerRequestFilter;&#10;import jakarta.ws.rs.core.Response;&#10;import jakarta.ws.rs.ext.Provider;&#10;&#10;import java.io.IOException;&#10;&#10;@Provider&#10;@Priority(Priorities.AUTHENTICATION)&#10;public class JwtFilter implements ContainerRequestFilter {&#10;&#10;    @Override&#10;    public void filter(ContainerRequestContext requestContext) throws IOException {&#10;        String path = requestContext.getUriInfo().getPath();&#10;        String method = requestContext.getMethod();&#10;        &#10;        System.out.println(&quot;[JWT Filter] Path: &quot; + path + &quot;, Method: &quot; + method);&#10;&#10;        // Allow OPTIONS requests (for CORS preflight)&#10;        if (&quot;OPTIONS&quot;.equalsIgnoreCase(method)) {&#10;            System.out.println(&quot;[JWT Filter] OPTIONS request - allowing without token&quot;);&#10;            return;&#10;        }&#10;&#10;        // Allow unauthenticated access to auth endpoints and public event endpoints&#10;        // Check various path patterns that might appear&#10;        boolean isAuthEndpoint = path.contains(&quot;/auth&quot;) &amp;&amp; !path.contains(&quot;/authenticated&quot;);&#10;        boolean isPublicEndpoint = path.contains(&quot;/public&quot;);&#10;        &#10;        System.out.println(&quot;[JWT Filter] isAuthEndpoint: &quot; + isAuthEndpoint + &quot;, isPublicEndpoint: &quot; + isPublicEndpoint);&#10;        &#10;        if (isAuthEndpoint || isPublicEndpoint) {&#10;            System.out.println(&quot;[JWT Filter] Public/Auth endpoint - allowing access without token&quot;);&#10;            return;&#10;        }&#10;&#10;        String authHeader = requestContext.getHeaderString(&quot;Authorization&quot;);&#10;        &#10;        System.out.println(&quot;[JWT Filter] Authorization header: &quot; + (authHeader != null ? &quot;Present&quot; : &quot;Missing&quot;));&#10;&#10;        if (authHeader == null || !authHeader.startsWith(&quot;Bearer &quot;)) {&#10;            System.out.println(&quot;[JWT Filter] Missing or invalid Authorization header - blocking request&quot;);&#10;            requestContext.abortWith(&#10;                Response.status(Response.Status.UNAUTHORIZED)&#10;                    .entity(&quot;{\&quot;error\&quot;: \&quot;Missing or invalid Authorization header\&quot;}&quot;)&#10;                    .build()&#10;            );&#10;            return;&#10;        }&#10;&#10;        String token = authHeader.substring(&quot;Bearer &quot;.length());&#10;&#10;        try {&#10;            Claims claims = JwtUtil.validateToken(token);&#10;&#10;            requestContext.setProperty(&quot;claims&quot;, claims);&#10;            requestContext.setProperty(&quot;userId&quot;, claims.get(&quot;userId&quot;, Integer.class));&#10;            requestContext.setProperty(&quot;username&quot;, claims.getSubject());&#10;            requestContext.setProperty(&quot;isAdmin&quot;, claims.get(&quot;isAdmin&quot;, Boolean.class));&#10;            &#10;            System.out.println(&quot;[JWT Filter] Token validated successfully for user: &quot; + claims.getSubject());&#10;&#10;        } catch (RuntimeException e) {&#10;            System.out.println(&quot;[JWT Filter] Token validation failed: &quot; + e.getMessage());&#10;            requestContext.abortWith(&#10;                Response.status(Response.Status.UNAUTHORIZED)&#10;                    .entity(&quot;{\&quot;error\&quot;: \&quot;&quot; + e.getMessage() + &quot;\&quot;}&quot;)&#10;                    .build()&#10;            );&#10;        }&#10;    }&#10;}&#10;&#10;&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="package JWT;&#10;&#10;import io.jsonwebtoken.Claims;&#10;import jakarta.annotation.Priority;&#10;import jakarta.ws.rs.Priorities;&#10;import jakarta.ws.rs.container.ContainerRequestContext;&#10;import jakarta.ws.rs.container.ContainerRequestFilter;&#10;import jakarta.ws.rs.core.Response;&#10;import jakarta.ws.rs.ext.Provider;&#10;&#10;import java.io.IOException;&#10;&#10;@Provider&#10;@Priority(Priorities.AUTHENTICATION)&#10;public class JwtFilter implements ContainerRequestFilter {&#10;&#10;    @Override&#10;    public void filter(ContainerRequestContext requestContext) throws IOException {&#10;        String path = requestContext.getUriInfo().getPath();&#10;        String method = requestContext.getMethod();&#10;        &#10;        System.out.println(&quot;[JWT Filter] Path: &quot; + path + &quot;, Method: &quot; + method);&#10;&#10;        // Allow OPTIONS requests (for CORS preflight)&#10;        if (&quot;OPTIONS&quot;.equalsIgnoreCase(method)) {&#10;            System.out.println(&quot;[JWT Filter] OPTIONS request - allowing without token&quot;);&#10;            return;&#10;        }&#10;&#10;        // Allow unauthenticated access to auth endpoints and public event endpoints&#10;        // Path examples: &quot;auth/login&quot;, &quot;auth/register&quot;, &quot;public/events&quot;&#10;        if (path.startsWith(&quot;auth/&quot;) || path.startsWith(&quot;public/&quot;)) {&#10;            System.out.println(&quot;[JWT Filter] Public/Auth endpoint - allowing access without token&quot;);&#10;            return;&#10;        }&#10;&#10;        String authHeader = requestContext.getHeaderString(&quot;Authorization&quot;);&#10;        &#10;        System.out.println(&quot;[JWT Filter] Authorization header: &quot; + (authHeader != null ? &quot;Present&quot; : &quot;Missing&quot;));&#10;&#10;        if (authHeader == null || !authHeader.startsWith(&quot;Bearer &quot;)) {&#10;            System.out.println(&quot;[JWT Filter] Missing or invalid Authorization header - blocking request&quot;);&#10;            requestContext.abortWith(&#10;                Response.status(Response.Status.UNAUTHORIZED)&#10;                    .entity(&quot;{\&quot;error\&quot;: \&quot;Missing or invalid Authorization header\&quot;}&quot;)&#10;                    .build()&#10;            );&#10;            return;&#10;        }&#10;&#10;        String token = authHeader.substring(&quot;Bearer &quot;.length());&#10;&#10;        try {&#10;            Claims claims = JwtUtil.validateToken(token);&#10;&#10;            requestContext.setProperty(&quot;claims&quot;, claims);&#10;            requestContext.setProperty(&quot;userId&quot;, claims.get(&quot;userId&quot;, Integer.class));&#10;            requestContext.setProperty(&quot;username&quot;, claims.getSubject());&#10;            requestContext.setProperty(&quot;isAdmin&quot;, claims.get(&quot;isAdmin&quot;, Boolean.class));&#10;            &#10;            System.out.println(&quot;[JWT Filter] Token validated successfully for user: &quot; + claims.getSubject());&#10;&#10;        } catch (RuntimeException e) {&#10;            System.out.println(&quot;[JWT Filter] Token validation failed: &quot; + e.getMessage());&#10;            requestContext.abortWith(&#10;                Response.status(Response.Status.UNAUTHORIZED)&#10;                    .entity(&quot;{\&quot;error\&quot;: \&quot;&quot; + e.getMessage() + &quot;\&quot;}&quot;)&#10;                    .build()&#10;            );&#10;        }&#10;    }&#10;}&#10;&#10;&#10;&#10;&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>